ok: CLASS ..Calib3d : 


===== Header: /Users/Melancardie/Dropbox/Documents/code/Java/OwlExpress/lib/opencv-3.0.0-beta/modules/calib3d/include/opencv2/calib3d/calib3d_c.h =====
Namespaces: set([''])

--- Incoming ---
['const CV_ITERATIVE', '0', [], []]
ok: CONST CV_ITERATIVE=0

--- Incoming ---
['const CV_EPNP', '1', [], []]
ok: CONST CV_EPNP=1

--- Incoming ---
['const CV_P3P', '2', [], []]
ok: CONST CV_P3P=2

--- Incoming ---
['const CV_DLS', '3', [], []]
ok: CONST CV_DLS=3

--- Incoming ---
['const CvLevMarq.DONE', '0', [], []]
class not found: CONST DONE=0

--- Incoming ---
['const CvLevMarq.STARTED', '1', [], []]
class not found: CONST STARTED=1

--- Incoming ---
['const CvLevMarq.CALC_J', '2', [], []]
class not found: CONST CALC_J=2

--- Incoming ---
['const CvLevMarq.CHECK_ERR', '3', [], []]
class not found: CONST CHECK_ERR=3


===== Header: /Users/Melancardie/Dropbox/Documents/code/Java/OwlExpress/lib/opencv-3.0.0-beta/modules/calib3d/include/opencv2/calib3d.hpp =====
Namespaces: set(['', 'cv.fisheye', 'cv'])

--- Incoming ---
['const cv.LMEDS', '4', [], []]
ok: CONST LMEDS=4

--- Incoming ---
['const cv.RANSAC', '8', [], []]
ok: CONST RANSAC=8

--- Incoming ---
['const cv.SOLVEPNP_ITERATIVE', '0', [], []]
ok: CONST SOLVEPNP_ITERATIVE=0

--- Incoming ---
['const cv.SOLVEPNP_EPNP', '1', [], []]
ok: CONST SOLVEPNP_EPNP=1

--- Incoming ---
['const cv.SOLVEPNP_P3P', '2', [], []]
ok: CONST SOLVEPNP_P3P=2

--- Incoming ---
['const cv.SOLVEPNP_DLS', '3', [], []]
ok: CONST SOLVEPNP_DLS=3

--- Incoming ---
['const cv.SOLVEPNP_UPNP', '4', [], []]
ok: CONST SOLVEPNP_UPNP=4

--- Incoming ---
['const cv.CALIB_CB_ADAPTIVE_THRESH', '1', [], []]
ok: CONST CALIB_CB_ADAPTIVE_THRESH=1

--- Incoming ---
['const cv.CALIB_CB_NORMALIZE_IMAGE', '2', [], []]
ok: CONST CALIB_CB_NORMALIZE_IMAGE=2

--- Incoming ---
['const cv.CALIB_CB_FILTER_QUADS', '4', [], []]
ok: CONST CALIB_CB_FILTER_QUADS=4

--- Incoming ---
['const cv.CALIB_CB_FAST_CHECK', '8', [], []]
ok: CONST CALIB_CB_FAST_CHECK=8

--- Incoming ---
['const cv.CALIB_CB_SYMMETRIC_GRID', '1', [], []]
ok: CONST CALIB_CB_SYMMETRIC_GRID=1

--- Incoming ---
['const cv.CALIB_CB_ASYMMETRIC_GRID', '2', [], []]
ok: CONST CALIB_CB_ASYMMETRIC_GRID=2

--- Incoming ---
['const cv.CALIB_CB_CLUSTERING', '4', [], []]
ok: CONST CALIB_CB_CLUSTERING=4

--- Incoming ---
['const cv.CALIB_USE_INTRINSIC_GUESS', '0x00001', [], []]
manual: CONST CALIB_USE_INTRINSIC_GUESS=0x00001

--- Incoming ---
['const cv.CALIB_FIX_ASPECT_RATIO', '0x00002', [], []]
ok: CONST CALIB_FIX_ASPECT_RATIO=0x00002

--- Incoming ---
['const cv.CALIB_FIX_PRINCIPAL_POINT', '0x00004', [], []]
ok: CONST CALIB_FIX_PRINCIPAL_POINT=0x00004

--- Incoming ---
['const cv.CALIB_ZERO_TANGENT_DIST', '0x00008', [], []]
ok: CONST CALIB_ZERO_TANGENT_DIST=0x00008

--- Incoming ---
['const cv.CALIB_FIX_FOCAL_LENGTH', '0x00010', [], []]
ok: CONST CALIB_FIX_FOCAL_LENGTH=0x00010

--- Incoming ---
['const cv.CALIB_FIX_K1', '0x00020', [], []]
manual: CONST CALIB_FIX_K1=0x00020

--- Incoming ---
['const cv.CALIB_FIX_K2', '0x00040', [], []]
manual: CONST CALIB_FIX_K2=0x00040

--- Incoming ---
['const cv.CALIB_FIX_K3', '0x00080', [], []]
manual: CONST CALIB_FIX_K3=0x00080

--- Incoming ---
['const cv.CALIB_FIX_K4', '0x00800', [], []]
manual: CONST CALIB_FIX_K4=0x00800

--- Incoming ---
['const cv.CALIB_FIX_K5', '0x01000', [], []]
ok: CONST CALIB_FIX_K5=0x01000

--- Incoming ---
['const cv.CALIB_FIX_K6', '0x02000', [], []]
ok: CONST CALIB_FIX_K6=0x02000

--- Incoming ---
['const cv.CALIB_RATIONAL_MODEL', '0x04000', [], []]
ok: CONST CALIB_RATIONAL_MODEL=0x04000

--- Incoming ---
['const cv.CALIB_THIN_PRISM_MODEL', '0x08000', [], []]
ok: CONST CALIB_THIN_PRISM_MODEL=0x08000

--- Incoming ---
['const cv.CALIB_FIX_S1_S2_S3_S4', '0x10000', [], []]
ok: CONST CALIB_FIX_S1_S2_S3_S4=0x10000

--- Incoming ---
['const cv.CALIB_FIX_INTRINSIC', '0x00100', [], []]
manual: CONST CALIB_FIX_INTRINSIC=0x00100

--- Incoming ---
['const cv.CALIB_SAME_FOCAL_LENGTH', '0x00200', [], []]
ok: CONST CALIB_SAME_FOCAL_LENGTH=0x00200

--- Incoming ---
['const cv.CALIB_ZERO_DISPARITY', '0x00400', [], []]
ok: CONST CALIB_ZERO_DISPARITY=0x00400

--- Incoming ---
['const cv.FM_7POINT', '1', [], []]
ok: CONST FM_7POINT=1

--- Incoming ---
['const cv.FM_8POINT', '2', [], []]
ok: CONST FM_8POINT=2

--- Incoming ---
['const cv.FM_LMEDS', '4', [], []]
ok: CONST FM_LMEDS=4

--- Incoming ---
['const cv.FM_RANSAC', '8', [], []]
ok: CONST FM_RANSAC=8

--- Incoming ---
[   'cv.Rodrigues',
    'void',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', ['/O']],
        ['Mat', 'jacobian', 'Mat()', ['/O']]]]
ok: FUNC <void cv..Rodrigues [ARG Mat src=, ARG Mat dst=, ARG Mat jacobian=Mat()]>

--- Incoming ---
[   'cv.findHomography',
    'Mat',
    [],
    [   ['Mat', 'srcPoints', '', []],
        ['Mat', 'dstPoints', '', []],
        ['int', 'method', '0', []],
        ['double', 'ransacReprojThreshold', '3', []],
        ['Mat', 'mask', 'Mat()', ['/O']],
        ['int', 'maxIters', '2000', []],
        ['double', 'confidence', '0.995', []]]]
ok: FUNC <Mat cv..findHomography [ARG vector_Point2f srcPoints=, ARG vector_Point2f dstPoints=, ARG int method=0, ARG double ransacReprojThreshold=3, ARG Mat mask=Mat(), ARG int maxIters=2000, ARG double confidence=0.995]>

--- Incoming ---
[   'cv.RQDecomp3x3',
    'Vec3d',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'mtxR', '', ['/O']],
        ['Mat', 'mtxQ', '', ['/O']],
        ['Mat', 'Qx', 'Mat()', ['/O']],
        ['Mat', 'Qy', 'Mat()', ['/O']],
        ['Mat', 'Qz', 'Mat()', ['/O']]]]
ok: FUNC <Vec3d cv..RQDecomp3x3 [ARG Mat src=, ARG Mat mtxR=, ARG Mat mtxQ=, ARG Mat Qx=Mat(), ARG Mat Qy=Mat(), ARG Mat Qz=Mat()]>

--- Incoming ---
[   'cv.decomposeProjectionMatrix',
    'void',
    [],
    [   ['Mat', 'projMatrix', '', []],
        ['Mat', 'cameraMatrix', '', ['/O']],
        ['Mat', 'rotMatrix', '', ['/O']],
        ['Mat', 'transVect', '', ['/O']],
        ['Mat', 'rotMatrixX', 'Mat()', ['/O']],
        ['Mat', 'rotMatrixY', 'Mat()', ['/O']],
        ['Mat', 'rotMatrixZ', 'Mat()', ['/O']],
        ['Mat', 'eulerAngles', 'Mat()', ['/O']]]]
ok: FUNC <void cv..decomposeProjectionMatrix [ARG Mat projMatrix=, ARG Mat cameraMatrix=, ARG Mat rotMatrix=, ARG Mat transVect=, ARG Mat rotMatrixX=Mat(), ARG Mat rotMatrixY=Mat(), ARG Mat rotMatrixZ=Mat(), ARG Mat eulerAngles=Mat()]>

--- Incoming ---
[   'cv.matMulDeriv',
    'void',
    [],
    [   ['Mat', 'A', '', []],
        ['Mat', 'B', '', []],
        ['Mat', 'dABdA', '', ['/O']],
        ['Mat', 'dABdB', '', ['/O']]]]
ok: FUNC <void cv..matMulDeriv [ARG Mat A=, ARG Mat B=, ARG Mat dABdA=, ARG Mat dABdB=]>

--- Incoming ---
[   'cv.composeRT',
    'void',
    [],
    [   ['Mat', 'rvec1', '', []],
        ['Mat', 'tvec1', '', []],
        ['Mat', 'rvec2', '', []],
        ['Mat', 'tvec2', '', []],
        ['Mat', 'rvec3', '', ['/O']],
        ['Mat', 'tvec3', '', ['/O']],
        ['Mat', 'dr3dr1', 'Mat()', ['/O']],
        ['Mat', 'dr3dt1', 'Mat()', ['/O']],
        ['Mat', 'dr3dr2', 'Mat()', ['/O']],
        ['Mat', 'dr3dt2', 'Mat()', ['/O']],
        ['Mat', 'dt3dr1', 'Mat()', ['/O']],
        ['Mat', 'dt3dt1', 'Mat()', ['/O']],
        ['Mat', 'dt3dr2', 'Mat()', ['/O']],
        ['Mat', 'dt3dt2', 'Mat()', ['/O']]]]
ok: FUNC <void cv..composeRT [ARG Mat rvec1=, ARG Mat tvec1=, ARG Mat rvec2=, ARG Mat tvec2=, ARG Mat rvec3=, ARG Mat tvec3=, ARG Mat dr3dr1=Mat(), ARG Mat dr3dt1=Mat(), ARG Mat dr3dr2=Mat(), ARG Mat dr3dt2=Mat(), ARG Mat dt3dr1=Mat(), ARG Mat dt3dt1=Mat(), ARG Mat dt3dr2=Mat(), ARG Mat dt3dt2=Mat()]>

--- Incoming ---
[   'cv.projectPoints',
    'void',
    [],
    [   ['Mat', 'objectPoints', '', []],
        ['Mat', 'rvec', '', []],
        ['Mat', 'tvec', '', []],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'imagePoints', '', ['/O']],
        ['Mat', 'jacobian', 'Mat()', ['/O']],
        ['double', 'aspectRatio', '0', []]]]
ok: FUNC <void cv..projectPoints [ARG vector_Point3f objectPoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG vector_Point2f imagePoints=, ARG Mat jacobian=Mat(), ARG double aspectRatio=0]>

--- Incoming ---
[   'cv.solvePnP',
    'bool',
    [],
    [   ['Mat', 'objectPoints', '', []],
        ['Mat', 'imagePoints', '', []],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'rvec', '', ['/O']],
        ['Mat', 'tvec', '', ['/O']],
        ['bool', 'useExtrinsicGuess', 'false', []],
        ['int', 'flags', 'SOLVEPNP_ITERATIVE', []]]]
ok: FUNC <bool cv..solvePnP [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int flags=SOLVEPNP_ITERATIVE]>

--- Incoming ---
[   'cv.solvePnPRansac',
    'bool',
    [],
    [   ['Mat', 'objectPoints', '', []],
        ['Mat', 'imagePoints', '', []],
        ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Mat', 'rvec', '', ['/O']],
        ['Mat', 'tvec', '', ['/O']],
        ['bool', 'useExtrinsicGuess', 'false', []],
        ['int', 'iterationsCount', '100', []],
        ['float', 'reprojectionError', '8.0', []],
        ['double', 'confidence', '0.99', []],
        ['Mat', 'inliers', 'Mat()', ['/O']],
        ['int', 'flags', 'SOLVEPNP_ITERATIVE', []]]]
ok: FUNC <bool cv..solvePnPRansac [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int iterationsCount=100, ARG float reprojectionError=8.0, ARG double confidence=0.99, ARG Mat inliers=Mat(), ARG int flags=SOLVEPNP_ITERATIVE]>

--- Incoming ---
[   'cv.initCameraMatrix2D',
    'Mat',
    [],
    [   ['vector_Mat', 'objectPoints', '', []],
        ['vector_Mat', 'imagePoints', '', []],
        ['Size', 'imageSize', '', []],
        ['double', 'aspectRatio', '1.0', []]]]
ok: FUNC <Mat cv..initCameraMatrix2D [ARG vector_vector_Point3f objectPoints=, ARG vector_vector_Point2f imagePoints=, ARG Size imageSize=, ARG double aspectRatio=1.0]>

--- Incoming ---
[   'cv.findChessboardCorners',
    'bool',
    [],
    [   ['Mat', 'image', '', []],
        ['Size', 'patternSize', '', []],
        ['Mat', 'corners', '', ['/O']],
        [   'int',
            'flags',
            'CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE',
            []]]]
ok: FUNC <bool cv..findChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG int flags=CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE]>

--- Incoming ---
[   'cv.drawChessboardCorners',
    'void',
    [],
    [   ['Mat', 'image', '', ['/IO']],
        ['Size', 'patternSize', '', []],
        ['Mat', 'corners', '', []],
        ['bool', 'patternWasFound', '', []]]]
ok: FUNC <void cv..drawChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG bool patternWasFound=]>

--- Incoming ---
[   'cv.findCirclesGrid',
    'bool',
    [],
    [   ['Mat', 'image', '', []],
        ['Size', 'patternSize', '', []],
        ['Mat', 'centers', '', ['/O']],
        ['int', 'flags', 'CALIB_CB_SYMMETRIC_GRID', []],
        [   'Ptr_FeatureDetector',
            'blobDetector',
            'SimpleBlobDetector::create()',
            []]]]
ok: FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=CALIB_CB_SYMMETRIC_GRID, ARG Ptr_FeatureDetector blobDetector=SimpleBlobDetector::create()]>

--- Incoming ---
[   'cv.calibrateCamera',
    'double',
    [],
    [   ['vector_Mat', 'objectPoints', '', []],
        ['vector_Mat', 'imagePoints', '', []],
        ['Size', 'imageSize', '', []],
        ['Mat', 'cameraMatrix', '', ['/IO']],
        ['Mat', 'distCoeffs', '', ['/IO']],
        ['vector_Mat', 'rvecs', '', ['/O']],
        ['vector_Mat', 'tvecs', '', ['/O']],
        ['int', 'flags', '0', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)',
            []]]]
ok: FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>

--- Incoming ---
[   'cv.calibrationMatrixValues',
    'void',
    [],
    [   ['Mat', 'cameraMatrix', '', []],
        ['Size', 'imageSize', '', []],
        ['double', 'apertureWidth', '', []],
        ['double', 'apertureHeight', '', []],
        ['double', 'fovx', '', ['/O']],
        ['double', 'fovy', '', ['/O']],
        ['double', 'focalLength', '', ['/O']],
        ['Point2d', 'principalPoint', '', ['/O']],
        ['double', 'aspectRatio', '', ['/O']]]]
ok: FUNC <void cv..calibrationMatrixValues [ARG Mat cameraMatrix=, ARG Size imageSize=, ARG double apertureWidth=, ARG double apertureHeight=, ARG double fovx=, ARG double fovy=, ARG double focalLength=, ARG Point2d principalPoint=, ARG double aspectRatio=]>

--- Incoming ---
[   'cv.stereoCalibrate',
    'double',
    [],
    [   ['vector_Mat', 'objectPoints', '', []],
        ['vector_Mat', 'imagePoints1', '', []],
        ['vector_Mat', 'imagePoints2', '', []],
        ['Mat', 'cameraMatrix1', '', ['/IO']],
        ['Mat', 'distCoeffs1', '', ['/IO']],
        ['Mat', 'cameraMatrix2', '', ['/IO']],
        ['Mat', 'distCoeffs2', '', ['/IO']],
        ['Size', 'imageSize', '', []],
        ['Mat', 'R', '', ['/O']],
        ['Mat', 'T', '', ['/O']],
        ['Mat', 'E', '', ['/O']],
        ['Mat', 'F', '', ['/O']],
        ['int', 'flags', 'CALIB_FIX_INTRINSIC', []],
        [   'TermCriteria',
            'criteria',
            'TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)',
            []]]]
ok: FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>

--- Incoming ---
[   'cv.stereoRectify',
    'void',
    [],
    [   ['Mat', 'cameraMatrix1', '', []],
        ['Mat', 'distCoeffs1', '', []],
        ['Mat', 'cameraMatrix2', '', []],
        ['Mat', 'distCoeffs2', '', []],
        ['Size', 'imageSize', '', []],
        ['Mat', 'R', '', []],
        ['Mat', 'T', '', []],
        ['Mat', 'R1', '', ['/O']],
        ['Mat', 'R2', '', ['/O']],
        ['Mat', 'P1', '', ['/O']],
        ['Mat', 'P2', '', ['/O']],
        ['Mat', 'Q', '', ['/O']],
        ['int', 'flags', 'CALIB_ZERO_DISPARITY', []],
        ['double', 'alpha', '-1', []],
        ['Size', 'newImageSize', 'Size()', []],
        ['Rect*', 'validPixROI1', '0', ['/O']],
        ['Rect*', 'validPixROI2', '0', ['/O']]]]
ok: FUNC <void cv..stereoRectify [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=CALIB_ZERO_DISPARITY, ARG double alpha=-1, ARG Size newImageSize=Size(), ARG Rect * validPixROI1=0, ARG Rect * validPixROI2=0]>

--- Incoming ---
[   'cv.stereoRectifyUncalibrated',
    'bool',
    [],
    [   ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['Mat', 'F', '', []],
        ['Size', 'imgSize', '', []],
        ['Mat', 'H1', '', ['/O']],
        ['Mat', 'H2', '', ['/O']],
        ['double', 'threshold', '5', []]]]
ok: FUNC <bool cv..stereoRectifyUncalibrated [ARG Mat points1=, ARG Mat points2=, ARG Mat F=, ARG Size imgSize=, ARG Mat H1=, ARG Mat H2=, ARG double threshold=5]>

--- Incoming ---
[   'cv.rectify3Collinear',
    'float',
    [],
    [   ['Mat', 'cameraMatrix1', '', []],
        ['Mat', 'distCoeffs1', '', []],
        ['Mat', 'cameraMatrix2', '', []],
        ['Mat', 'distCoeffs2', '', []],
        ['Mat', 'cameraMatrix3', '', []],
        ['Mat', 'distCoeffs3', '', []],
        ['vector_Mat', 'imgpt1', '', []],
        ['vector_Mat', 'imgpt3', '', []],
        ['Size', 'imageSize', '', []],
        ['Mat', 'R12', '', []],
        ['Mat', 'T12', '', []],
        ['Mat', 'R13', '', []],
        ['Mat', 'T13', '', []],
        ['Mat', 'R1', '', ['/O']],
        ['Mat', 'R2', '', ['/O']],
        ['Mat', 'R3', '', ['/O']],
        ['Mat', 'P1', '', ['/O']],
        ['Mat', 'P2', '', ['/O']],
        ['Mat', 'P3', '', ['/O']],
        ['Mat', 'Q', '', ['/O']],
        ['double', 'alpha', '', []],
        ['Size', 'newImgSize', '', []],
        ['Rect*', 'roi1', '', ['/O']],
        ['Rect*', 'roi2', '', ['/O']],
        ['int', 'flags', '', []]]]
ok: FUNC <float cv..rectify3Collinear [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Mat cameraMatrix3=, ARG Mat distCoeffs3=, ARG vector_Mat imgpt1=, ARG vector_Mat imgpt3=, ARG Size imageSize=, ARG Mat R12=, ARG Mat T12=, ARG Mat R13=, ARG Mat T13=, ARG Mat R1=, ARG Mat R2=, ARG Mat R3=, ARG Mat P1=, ARG Mat P2=, ARG Mat P3=, ARG Mat Q=, ARG double alpha=, ARG Size newImgSize=, ARG Rect * roi1=, ARG Rect * roi2=, ARG int flags=]>

--- Incoming ---
[   'cv.getOptimalNewCameraMatrix',
    'Mat',
    [],
    [   ['Mat', 'cameraMatrix', '', []],
        ['Mat', 'distCoeffs', '', []],
        ['Size', 'imageSize', '', []],
        ['double', 'alpha', '', []],
        ['Size', 'newImgSize', 'Size()', []],
        ['Rect*', 'validPixROI', '0', ['/O']],
        ['bool', 'centerPrincipalPoint', 'false', []]]]
ok: FUNC <Mat cv..getOptimalNewCameraMatrix [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Size imageSize=, ARG double alpha=, ARG Size newImgSize=Size(), ARG Rect * validPixROI=0, ARG bool centerPrincipalPoint=false]>

--- Incoming ---
[   'cv.convertPointsToHomogeneous',
    'void',
    [],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]]]
ok: FUNC <void cv..convertPointsToHomogeneous [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.convertPointsFromHomogeneous',
    'void',
    [],
    [['Mat', 'src', '', []], ['Mat', 'dst', '', ['/O']]]]
ok: FUNC <void cv..convertPointsFromHomogeneous [ARG Mat src=, ARG Mat dst=]>

--- Incoming ---
[   'cv.findFundamentalMat',
    'Mat',
    [],
    [   ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['int', 'method', 'FM_RANSAC', []],
        ['double', 'param1', '3.', []],
        ['double', 'param2', '0.99', []],
        ['Mat', 'mask', 'Mat()', ['/O']]]]
ok: FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG int method=FM_RANSAC, ARG double param1=3., ARG double param2=0.99, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.findEssentialMat',
    'Mat',
    [],
    [   ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['double', 'focal', '1.0', []],
        ['Point2d', 'pp', 'Point2d(0, 0)', []],
        ['int', 'method', 'RANSAC', []],
        ['double', 'prob', '0.999', []],
        ['double', 'threshold', '1.0', []],
        ['Mat', 'mask', 'Mat()', ['/O']]]]
ok: FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.decomposeEssentialMat',
    'void',
    [],
    [   ['Mat', 'E', '', []],
        ['Mat', 'R1', '', ['/O']],
        ['Mat', 'R2', '', ['/O']],
        ['Mat', 't', '', ['/O']]]]
ok: FUNC <void cv..decomposeEssentialMat [ARG Mat E=, ARG Mat R1=, ARG Mat R2=, ARG Mat t=]>

--- Incoming ---
[   'cv.recoverPose',
    'int',
    [],
    [   ['Mat', 'E', '', []],
        ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['Mat', 'R', '', ['/O']],
        ['Mat', 't', '', ['/O']],
        ['double', 'focal', '1.0', []],
        ['Point2d', 'pp', 'Point2d(0, 0)', []],
        ['Mat', 'mask', 'Mat()', ['/IO']]]]
ok: FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat R=, ARG Mat t=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG Mat mask=Mat()]>

--- Incoming ---
[   'cv.computeCorrespondEpilines',
    'void',
    [],
    [   ['Mat', 'points', '', []],
        ['int', 'whichImage', '', []],
        ['Mat', 'F', '', []],
        ['Mat', 'lines', '', ['/O']]]]
ok: FUNC <void cv..computeCorrespondEpilines [ARG Mat points=, ARG int whichImage=, ARG Mat F=, ARG Mat lines=]>

--- Incoming ---
[   'cv.triangulatePoints',
    'void',
    [],
    [   ['Mat', 'projMatr1', '', []],
        ['Mat', 'projMatr2', '', []],
        ['Mat', 'projPoints1', '', []],
        ['Mat', 'projPoints2', '', []],
        ['Mat', 'points4D', '', ['/O']]]]
ok: FUNC <void cv..triangulatePoints [ARG Mat projMatr1=, ARG Mat projMatr2=, ARG Mat projPoints1=, ARG Mat projPoints2=, ARG Mat points4D=]>

--- Incoming ---
[   'cv.correctMatches',
    'void',
    [],
    [   ['Mat', 'F', '', []],
        ['Mat', 'points1', '', []],
        ['Mat', 'points2', '', []],
        ['Mat', 'newPoints1', '', ['/O']],
        ['Mat', 'newPoints2', '', ['/O']]]]
ok: FUNC <void cv..correctMatches [ARG Mat F=, ARG Mat points1=, ARG Mat points2=, ARG Mat newPoints1=, ARG Mat newPoints2=]>

--- Incoming ---
[   'cv.filterSpeckles',
    'void',
    [],
    [   ['Mat', 'img', '', ['/IO']],
        ['double', 'newVal', '', []],
        ['int', 'maxSpeckleSize', '', []],
        ['double', 'maxDiff', '', []],
        ['Mat', 'buf', 'Mat()', ['/IO']]]]
ok: FUNC <void cv..filterSpeckles [ARG Mat img=, ARG double newVal=, ARG int maxSpeckleSize=, ARG double maxDiff=, ARG Mat buf=Mat()]>

--- Incoming ---
[   'cv.getValidDisparityROI',
    'Rect',
    [],
    [   ['Rect', 'roi1', '', []],
        ['Rect', 'roi2', '', []],
        ['int', 'minDisparity', '', []],
        ['int', 'numberOfDisparities', '', []],
        ['int', 'SADWindowSize', '', []]]]
ok: FUNC <Rect cv..getValidDisparityROI [ARG Rect roi1=, ARG Rect roi2=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int SADWindowSize=]>

--- Incoming ---
[   'cv.validateDisparity',
    'void',
    [],
    [   ['Mat', 'disparity', '', ['/IO']],
        ['Mat', 'cost', '', []],
        ['int', 'minDisparity', '', []],
        ['int', 'numberOfDisparities', '', []],
        ['int', 'disp12MaxDisp', '1', []]]]
ok: FUNC <void cv..validateDisparity [ARG Mat disparity=, ARG Mat cost=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int disp12MaxDisp=1]>

--- Incoming ---
[   'cv.reprojectImageTo3D',
    'void',
    [],
    [   ['Mat', 'disparity', '', []],
        ['Mat', '_3dImage', '', ['/O']],
        ['Mat', 'Q', '', []],
        ['bool', 'handleMissingValues', 'false', []],
        ['int', 'ddepth', '-1', []]]]
ok: FUNC <void cv..reprojectImageTo3D [ARG Mat disparity=, ARG Mat _3dImage=, ARG Mat Q=, ARG bool handleMissingValues=false, ARG int ddepth=-1]>

--- Incoming ---
[   'cv.estimateAffine3D',
    'int',
    [],
    [   ['Mat', 'src', '', []],
        ['Mat', 'dst', '', []],
        ['Mat', 'out', '', ['/O']],
        ['Mat', 'inliers', '', ['/O']],
        ['double', 'ransacThreshold', '3', []],
        ['double', 'confidence', '0.99', []]]]
ok: FUNC <int cv..estimateAffine3D [ARG Mat src=, ARG Mat dst=, ARG Mat out=, ARG Mat inliers=, ARG double ransacThreshold=3, ARG double confidence=0.99]>

--- Incoming ---
[   'cv.decomposeHomographyMat',
    'int',
    [],
    [   ['Mat', 'H', '', []],
        ['Mat', 'K', '', []],
        ['vector_Mat', 'rotations', '', ['/O']],
        ['vector_Mat', 'translations', '', ['/O']],
        ['vector_Mat', 'normals', '', ['/O']]]]
ok: FUNC <int cv..decomposeHomographyMat [ARG Mat H=, ARG Mat K=, ARG vector_Mat rotations=, ARG vector_Mat translations=, ARG vector_Mat normals=]>

--- Incoming ---
['class cv.StereoMatcher', ': cv::Algorithm', [], []]
ok: CLASS cv..StereoMatcher : Algorithm

--- Incoming ---
['const cv.StereoMatcher.DISP_SHIFT', '4', [], []]
ok: CONST DISP_SHIFT=4

--- Incoming ---
['const cv.StereoMatcher.DISP_SCALE', '(1 << DISP_SHIFT)', [], []]
ok: CONST DISP_SCALE=(1 << DISP_SHIFT)

--- Incoming ---
[   'cv.StereoMatcher.compute',
    'void',
    [],
    [   ['Mat', 'left', '', []],
        ['Mat', 'right', '', []],
        ['Mat', 'disparity', '', ['/O']]]]
ok: FUNC <void cv.StereoMatcher.compute [ARG Mat left=, ARG Mat right=, ARG Mat disparity=]>

--- Incoming ---
['cv.StereoMatcher.getMinDisparity', 'int', [], []]
ok: FUNC <int cv.StereoMatcher.getMinDisparity []>

--- Incoming ---
[   'cv.StereoMatcher.setMinDisparity',
    'void',
    [],
    [['int', 'minDisparity', '', []]]]
ok: FUNC <void cv.StereoMatcher.setMinDisparity [ARG int minDisparity=]>

--- Incoming ---
['cv.StereoMatcher.getNumDisparities', 'int', [], []]
ok: FUNC <int cv.StereoMatcher.getNumDisparities []>

--- Incoming ---
[   'cv.StereoMatcher.setNumDisparities',
    'void',
    [],
    [['int', 'numDisparities', '', []]]]
ok: FUNC <void cv.StereoMatcher.setNumDisparities [ARG int numDisparities=]>

--- Incoming ---
['cv.StereoMatcher.getBlockSize', 'int', [], []]
ok: FUNC <int cv.StereoMatcher.getBlockSize []>

--- Incoming ---
['cv.StereoMatcher.setBlockSize', 'void', [], [['int', 'blockSize', '', []]]]
ok: FUNC <void cv.StereoMatcher.setBlockSize [ARG int blockSize=]>

--- Incoming ---
['cv.StereoMatcher.getSpeckleWindowSize', 'int', [], []]
ok: FUNC <int cv.StereoMatcher.getSpeckleWindowSize []>

--- Incoming ---
[   'cv.StereoMatcher.setSpeckleWindowSize',
    'void',
    [],
    [['int', 'speckleWindowSize', '', []]]]
ok: FUNC <void cv.StereoMatcher.setSpeckleWindowSize [ARG int speckleWindowSize=]>

--- Incoming ---
['cv.StereoMatcher.getSpeckleRange', 'int', [], []]
ok: FUNC <int cv.StereoMatcher.getSpeckleRange []>

--- Incoming ---
[   'cv.StereoMatcher.setSpeckleRange',
    'void',
    [],
    [['int', 'speckleRange', '', []]]]
ok: FUNC <void cv.StereoMatcher.setSpeckleRange [ARG int speckleRange=]>

--- Incoming ---
['cv.StereoMatcher.getDisp12MaxDiff', 'int', [], []]
ok: FUNC <int cv.StereoMatcher.getDisp12MaxDiff []>

--- Incoming ---
[   'cv.StereoMatcher.setDisp12MaxDiff',
    'void',
    [],
    [['int', 'disp12MaxDiff', '', []]]]
ok: FUNC <void cv.StereoMatcher.setDisp12MaxDiff [ARG int disp12MaxDiff=]>

--- Incoming ---
['class cv.StereoBM', ': cv::StereoMatcher', [], []]
ok: CLASS cv..StereoBM : StereoMatcher

--- Incoming ---
['const cv.StereoBM.PREFILTER_NORMALIZED_RESPONSE', '0', [], []]
ok: CONST PREFILTER_NORMALIZED_RESPONSE=0

--- Incoming ---
['const cv.StereoBM.PREFILTER_XSOBEL', '1', [], []]
ok: CONST PREFILTER_XSOBEL=1

--- Incoming ---
['cv.StereoBM.getPreFilterType', 'int', [], []]
ok: FUNC <int cv.StereoBM.getPreFilterType []>

--- Incoming ---
[   'cv.StereoBM.setPreFilterType',
    'void',
    [],
    [['int', 'preFilterType', '', []]]]
ok: FUNC <void cv.StereoBM.setPreFilterType [ARG int preFilterType=]>

--- Incoming ---
['cv.StereoBM.getPreFilterSize', 'int', [], []]
ok: FUNC <int cv.StereoBM.getPreFilterSize []>

--- Incoming ---
[   'cv.StereoBM.setPreFilterSize',
    'void',
    [],
    [['int', 'preFilterSize', '', []]]]
ok: FUNC <void cv.StereoBM.setPreFilterSize [ARG int preFilterSize=]>

--- Incoming ---
['cv.StereoBM.getPreFilterCap', 'int', [], []]
ok: FUNC <int cv.StereoBM.getPreFilterCap []>

--- Incoming ---
['cv.StereoBM.setPreFilterCap', 'void', [], [['int', 'preFilterCap', '', []]]]
ok: FUNC <void cv.StereoBM.setPreFilterCap [ARG int preFilterCap=]>

--- Incoming ---
['cv.StereoBM.getTextureThreshold', 'int', [], []]
ok: FUNC <int cv.StereoBM.getTextureThreshold []>

--- Incoming ---
[   'cv.StereoBM.setTextureThreshold',
    'void',
    [],
    [['int', 'textureThreshold', '', []]]]
ok: FUNC <void cv.StereoBM.setTextureThreshold [ARG int textureThreshold=]>

--- Incoming ---
['cv.StereoBM.getUniquenessRatio', 'int', [], []]
ok: FUNC <int cv.StereoBM.getUniquenessRatio []>

--- Incoming ---
[   'cv.StereoBM.setUniquenessRatio',
    'void',
    [],
    [['int', 'uniquenessRatio', '', []]]]
ok: FUNC <void cv.StereoBM.setUniquenessRatio [ARG int uniquenessRatio=]>

--- Incoming ---
['cv.StereoBM.getSmallerBlockSize', 'int', [], []]
ok: FUNC <int cv.StereoBM.getSmallerBlockSize []>

--- Incoming ---
['cv.StereoBM.setSmallerBlockSize', 'void', [], [['int', 'blockSize', '', []]]]
ok: FUNC <void cv.StereoBM.setSmallerBlockSize [ARG int blockSize=]>

--- Incoming ---
['cv.StereoBM.getROI1', 'Rect', [], []]
ok: FUNC <Rect cv.StereoBM.getROI1 []>

--- Incoming ---
['cv.StereoBM.setROI1', 'void', [], [['Rect', 'roi1', '', []]]]
ok: FUNC <void cv.StereoBM.setROI1 [ARG Rect roi1=]>

--- Incoming ---
['cv.StereoBM.getROI2', 'Rect', [], []]
ok: FUNC <Rect cv.StereoBM.getROI2 []>

--- Incoming ---
['cv.StereoBM.setROI2', 'void', [], [['Rect', 'roi2', '', []]]]
ok: FUNC <void cv.StereoBM.setROI2 [ARG Rect roi2=]>

--- Incoming ---
[   'cv.StereoBM.create',
    'Ptr_StereoBM',
    ['/S'],
    [['int', 'numDisparities', '0', []], ['int', 'blockSize', '21', []]]]
ok: FUNC <Ptr_StereoBM cv.StereoBM.create [ARG int numDisparities=0, ARG int blockSize=21]>

--- Incoming ---
['class cv.StereoSGBM', ': cv::StereoMatcher', [], []]
ok: CLASS cv..StereoSGBM : StereoMatcher

--- Incoming ---
['const cv.StereoSGBM.MODE_SGBM', '0', [], []]
ok: CONST MODE_SGBM=0

--- Incoming ---
['const cv.StereoSGBM.MODE_HH', '1', [], []]
ok: CONST MODE_HH=1

--- Incoming ---
['cv.StereoSGBM.getPreFilterCap', 'int', [], []]
ok: FUNC <int cv.StereoSGBM.getPreFilterCap []>

--- Incoming ---
[   'cv.StereoSGBM.setPreFilterCap',
    'void',
    [],
    [['int', 'preFilterCap', '', []]]]
ok: FUNC <void cv.StereoSGBM.setPreFilterCap [ARG int preFilterCap=]>

--- Incoming ---
['cv.StereoSGBM.getUniquenessRatio', 'int', [], []]
ok: FUNC <int cv.StereoSGBM.getUniquenessRatio []>

--- Incoming ---
[   'cv.StereoSGBM.setUniquenessRatio',
    'void',
    [],
    [['int', 'uniquenessRatio', '', []]]]
ok: FUNC <void cv.StereoSGBM.setUniquenessRatio [ARG int uniquenessRatio=]>

--- Incoming ---
['cv.StereoSGBM.getP1', 'int', [], []]
ok: FUNC <int cv.StereoSGBM.getP1 []>

--- Incoming ---
['cv.StereoSGBM.setP1', 'void', [], [['int', 'P1', '', []]]]
ok: FUNC <void cv.StereoSGBM.setP1 [ARG int P1=]>

--- Incoming ---
['cv.StereoSGBM.getP2', 'int', [], []]
ok: FUNC <int cv.StereoSGBM.getP2 []>

--- Incoming ---
['cv.StereoSGBM.setP2', 'void', [], [['int', 'P2', '', []]]]
ok: FUNC <void cv.StereoSGBM.setP2 [ARG int P2=]>

--- Incoming ---
['cv.StereoSGBM.getMode', 'int', [], []]
ok: FUNC <int cv.StereoSGBM.getMode []>

--- Incoming ---
['cv.StereoSGBM.setMode', 'void', [], [['int', 'mode', '', []]]]
ok: FUNC <void cv.StereoSGBM.setMode [ARG int mode=]>

--- Incoming ---
[   'cv.StereoSGBM.create',
    'Ptr_StereoSGBM',
    ['/S'],
    [   ['int', 'minDisparity', '', []],
        ['int', 'numDisparities', '', []],
        ['int', 'blockSize', '', []],
        ['int', 'P1', '0', []],
        ['int', 'P2', '0', []],
        ['int', 'disp12MaxDiff', '0', []],
        ['int', 'preFilterCap', '0', []],
        ['int', 'uniquenessRatio', '0', []],
        ['int', 'speckleWindowSize', '0', []],
        ['int', 'speckleRange', '0', []],
        ['int', 'mode', 'StereoSGBM::MODE_SGBM', []]]]
ok: FUNC <Ptr_StereoSGBM cv.StereoSGBM.create [ARG int minDisparity=, ARG int numDisparities=, ARG int blockSize=, ARG int P1=0, ARG int P2=0, ARG int disp12MaxDiff=0, ARG int preFilterCap=0, ARG int uniquenessRatio=0, ARG int speckleWindowSize=0, ARG int speckleRange=0, ARG int mode=StereoSGBM::MODE_SGBM]>

--- Incoming ---
['const cv.fisheye.CALIB_USE_INTRINSIC_GUESS', '1', [], []]
manual: CONST CALIB_USE_INTRINSIC_GUESS=1

--- Incoming ---
['const cv.fisheye.CALIB_RECOMPUTE_EXTRINSIC', '2', [], []]
manual: CONST CALIB_RECOMPUTE_EXTRINSIC=2

--- Incoming ---
['const cv.fisheye.CALIB_CHECK_COND', '4', [], []]
manual: CONST CALIB_CHECK_COND=4

--- Incoming ---
['const cv.fisheye.CALIB_FIX_SKEW', '8', [], []]
manual: CONST CALIB_FIX_SKEW=8

--- Incoming ---
['const cv.fisheye.CALIB_FIX_K1', '16', [], []]
manual: CONST CALIB_FIX_K1=16

--- Incoming ---
['const cv.fisheye.CALIB_FIX_K2', '32', [], []]
manual: CONST CALIB_FIX_K2=32

--- Incoming ---
['const cv.fisheye.CALIB_FIX_K3', '64', [], []]
manual: CONST CALIB_FIX_K3=64

--- Incoming ---
['const cv.fisheye.CALIB_FIX_K4', '128', [], []]
manual: CONST CALIB_FIX_K4=128

--- Incoming ---
['const cv.fisheye.CALIB_FIX_INTRINSIC', '256', [], []]
manual: CONST CALIB_FIX_INTRINSIC=256


===== Header: /Users/Melancardie/Dropbox/Documents/code/Java/OwlExpress/lib/opencv-3.0.0-beta/modules/calib3d/include/opencv2/calib3d/calib3d.hpp =====
Namespaces: set(['', 'cv.fisheye', 'cv'])


===== Generating... =====
CLASS cv..StereoSGBM : StereoMatcher
[CONST MODE_SGBM=0, CONST MODE_HH=1]
FUNC <int cv.StereoSGBM.getPreFilterCap []>
FUNC <void cv.StereoSGBM.setPreFilterCap [ARG int preFilterCap=]>
FUNC <int cv.StereoSGBM.getUniquenessRatio []>
FUNC <void cv.StereoSGBM.setUniquenessRatio [ARG int uniquenessRatio=]>
FUNC <int cv.StereoSGBM.getP1 []>
FUNC <void cv.StereoSGBM.setP1 [ARG int P1=]>
FUNC <int cv.StereoSGBM.getP2 []>
FUNC <void cv.StereoSGBM.setP2 [ARG int P2=]>
FUNC <int cv.StereoSGBM.getMode []>
FUNC <void cv.StereoSGBM.setMode [ARG int mode=]>
FUNC <Ptr_StereoSGBM cv.StereoSGBM.create [ARG int minDisparity=, ARG int numDisparities=, ARG int blockSize=, ARG int P1=0, ARG int P2=0, ARG int disp12MaxDiff=0, ARG int preFilterCap=0, ARG int uniquenessRatio=0, ARG int speckleWindowSize=0, ARG int speckleRange=0, ARG int mode=StereoSGBM::MODE_SGBM]>
CLASS cv..StereoBM : StereoMatcher
[CONST PREFILTER_NORMALIZED_RESPONSE=0, CONST PREFILTER_XSOBEL=1]
FUNC <int cv.StereoBM.getPreFilterType []>
FUNC <void cv.StereoBM.setPreFilterType [ARG int preFilterType=]>
FUNC <int cv.StereoBM.getPreFilterSize []>
FUNC <void cv.StereoBM.setPreFilterSize [ARG int preFilterSize=]>
FUNC <int cv.StereoBM.getPreFilterCap []>
FUNC <void cv.StereoBM.setPreFilterCap [ARG int preFilterCap=]>
FUNC <int cv.StereoBM.getTextureThreshold []>
FUNC <void cv.StereoBM.setTextureThreshold [ARG int textureThreshold=]>
FUNC <int cv.StereoBM.getUniquenessRatio []>
FUNC <void cv.StereoBM.setUniquenessRatio [ARG int uniquenessRatio=]>
FUNC <int cv.StereoBM.getSmallerBlockSize []>
FUNC <void cv.StereoBM.setSmallerBlockSize [ARG int blockSize=]>
FUNC <Rect cv.StereoBM.getROI1 []>
FUNC <void cv.StereoBM.setROI1 [ARG Rect roi1=]>
FUNC <Rect cv.StereoBM.getROI2 []>
FUNC <void cv.StereoBM.setROI2 [ARG Rect roi2=]>
FUNC <Ptr_StereoBM cv.StereoBM.create [ARG int numDisparities=0, ARG int blockSize=21]>
CLASS cv..StereoMatcher : Algorithm
[CONST DISP_SHIFT=4, CONST DISP_SCALE=(1 << DISP_SHIFT)]
FUNC <void cv.StereoMatcher.compute [ARG Mat left=, ARG Mat right=, ARG Mat disparity=]>
FUNC <int cv.StereoMatcher.getMinDisparity []>
FUNC <void cv.StereoMatcher.setMinDisparity [ARG int minDisparity=]>
FUNC <int cv.StereoMatcher.getNumDisparities []>
FUNC <void cv.StereoMatcher.setNumDisparities [ARG int numDisparities=]>
FUNC <int cv.StereoMatcher.getBlockSize []>
FUNC <void cv.StereoMatcher.setBlockSize [ARG int blockSize=]>
FUNC <int cv.StereoMatcher.getSpeckleWindowSize []>
FUNC <void cv.StereoMatcher.setSpeckleWindowSize [ARG int speckleWindowSize=]>
FUNC <int cv.StereoMatcher.getSpeckleRange []>
FUNC <void cv.StereoMatcher.setSpeckleRange [ARG int speckleRange=]>
FUNC <int cv.StereoMatcher.getDisp12MaxDiff []>
FUNC <void cv.StereoMatcher.setDisp12MaxDiff [ARG int disp12MaxDiff=]>
CLASS ..Calib3d : 
[CONST CALIB_USE_INTRINSIC_GUESS=1(manual), CONST CALIB_RECOMPUTE_EXTRINSIC=2(manual), CONST CALIB_CHECK_COND=4(manual), CONST CALIB_FIX_SKEW=8(manual), CONST CALIB_FIX_K1=16(manual), CONST CALIB_FIX_K2=32(manual), CONST CALIB_FIX_K3=64(manual), CONST CALIB_FIX_K4=128(manual), CONST CALIB_FIX_INTRINSIC=256(manual), CONST CV_ITERATIVE=0, CONST CV_EPNP=1, CONST CV_P3P=2, CONST CV_DLS=3, CONST LMEDS=4, CONST RANSAC=8, CONST SOLVEPNP_ITERATIVE=0, CONST SOLVEPNP_EPNP=1, CONST SOLVEPNP_P3P=2, CONST SOLVEPNP_DLS=3, CONST SOLVEPNP_UPNP=4, CONST CALIB_CB_ADAPTIVE_THRESH=1, CONST CALIB_CB_NORMALIZE_IMAGE=2, CONST CALIB_CB_FILTER_QUADS=4, CONST CALIB_CB_FAST_CHECK=8, CONST CALIB_CB_SYMMETRIC_GRID=1, CONST CALIB_CB_ASYMMETRIC_GRID=2, CONST CALIB_CB_CLUSTERING=4, CONST CALIB_FIX_ASPECT_RATIO=0x00002, CONST CALIB_FIX_PRINCIPAL_POINT=0x00004, CONST CALIB_ZERO_TANGENT_DIST=0x00008, CONST CALIB_FIX_FOCAL_LENGTH=0x00010, CONST CALIB_FIX_K5=0x01000, CONST CALIB_FIX_K6=0x02000, CONST CALIB_RATIONAL_MODEL=0x04000, CONST CALIB_THIN_PRISM_MODEL=0x08000, CONST CALIB_FIX_S1_S2_S3_S4=0x10000, CONST CALIB_SAME_FOCAL_LENGTH=0x00200, CONST CALIB_ZERO_DISPARITY=0x00400, CONST FM_7POINT=1, CONST FM_8POINT=2, CONST FM_LMEDS=4, CONST FM_RANSAC=8]
FUNC <Mat cv..findEssentialMat [ARG Mat points1=, ARG Mat points2=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG int method=RANSAC, ARG double prob=0.999, ARG double threshold=1.0, ARG Mat mask=Mat()]>
FUNC <void cv..decomposeEssentialMat [ARG Mat E=, ARG Mat R1=, ARG Mat R2=, ARG Mat t=]>
FUNC <int cv..recoverPose [ARG Mat E=, ARG Mat points1=, ARG Mat points2=, ARG Mat R=, ARG Mat t=, ARG double focal=1.0, ARG Point2d pp=Point2d(0, 0), ARG Mat mask=Mat()]>
FUNC <void cv..computeCorrespondEpilines [ARG Mat points=, ARG int whichImage=, ARG Mat F=, ARG Mat lines=]>
FUNC <void cv..triangulatePoints [ARG Mat projMatr1=, ARG Mat projMatr2=, ARG Mat projPoints1=, ARG Mat projPoints2=, ARG Mat points4D=]>
FUNC <void cv..correctMatches [ARG Mat F=, ARG Mat points1=, ARG Mat points2=, ARG Mat newPoints1=, ARG Mat newPoints2=]>
FUNC <void cv..filterSpeckles [ARG Mat img=, ARG double newVal=, ARG int maxSpeckleSize=, ARG double maxDiff=, ARG Mat buf=Mat()]>
FUNC <Rect cv..getValidDisparityROI [ARG Rect roi1=, ARG Rect roi2=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int SADWindowSize=]>
FUNC <void cv..validateDisparity [ARG Mat disparity=, ARG Mat cost=, ARG int minDisparity=, ARG int numberOfDisparities=, ARG int disp12MaxDisp=1]>
FUNC <void cv..reprojectImageTo3D [ARG Mat disparity=, ARG Mat _3dImage=, ARG Mat Q=, ARG bool handleMissingValues=false, ARG int ddepth=-1]>
FUNC <int cv..estimateAffine3D [ARG Mat src=, ARG Mat dst=, ARG Mat out=, ARG Mat inliers=, ARG double ransacThreshold=3, ARG double confidence=0.99]>
FUNC <int cv..decomposeHomographyMat [ARG Mat H=, ARG Mat K=, ARG vector_Mat rotations=, ARG vector_Mat translations=, ARG vector_Mat normals=]>
FUNC <void cv..Rodrigues [ARG Mat src=, ARG Mat dst=, ARG Mat jacobian=Mat()]>
FUNC <Mat cv..findHomography [ARG vector_Point2f srcPoints=, ARG vector_Point2f dstPoints=, ARG int method=0, ARG double ransacReprojThreshold=3, ARG Mat mask=Mat(), ARG int maxIters=2000, ARG double confidence=0.995]>
FUNC <Vec3d cv..RQDecomp3x3 [ARG Mat src=, ARG Mat mtxR=, ARG Mat mtxQ=, ARG Mat Qx=Mat(), ARG Mat Qy=Mat(), ARG Mat Qz=Mat()]>
FUNC <void cv..decomposeProjectionMatrix [ARG Mat projMatrix=, ARG Mat cameraMatrix=, ARG Mat rotMatrix=, ARG Mat transVect=, ARG Mat rotMatrixX=Mat(), ARG Mat rotMatrixY=Mat(), ARG Mat rotMatrixZ=Mat(), ARG Mat eulerAngles=Mat()]>
FUNC <void cv..matMulDeriv [ARG Mat A=, ARG Mat B=, ARG Mat dABdA=, ARG Mat dABdB=]>
FUNC <void cv..composeRT [ARG Mat rvec1=, ARG Mat tvec1=, ARG Mat rvec2=, ARG Mat tvec2=, ARG Mat rvec3=, ARG Mat tvec3=, ARG Mat dr3dr1=Mat(), ARG Mat dr3dt1=Mat(), ARG Mat dr3dr2=Mat(), ARG Mat dr3dt2=Mat(), ARG Mat dt3dr1=Mat(), ARG Mat dt3dt1=Mat(), ARG Mat dt3dr2=Mat(), ARG Mat dt3dt2=Mat()]>
FUNC <void cv..projectPoints [ARG vector_Point3f objectPoints=, ARG Mat rvec=, ARG Mat tvec=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG vector_Point2f imagePoints=, ARG Mat jacobian=Mat(), ARG double aspectRatio=0]>
FUNC <bool cv..solvePnP [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int flags=SOLVEPNP_ITERATIVE]>
FUNC <bool cv..solvePnPRansac [ARG vector_Point3f objectPoints=, ARG vector_Point2f imagePoints=, ARG Mat cameraMatrix=, ARG vector_double distCoeffs=, ARG Mat rvec=, ARG Mat tvec=, ARG bool useExtrinsicGuess=false, ARG int iterationsCount=100, ARG float reprojectionError=8.0, ARG double confidence=0.99, ARG Mat inliers=Mat(), ARG int flags=SOLVEPNP_ITERATIVE]>
FUNC <bool cv..findChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG int flags=CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE]>
FUNC <Mat cv..initCameraMatrix2D [ARG vector_vector_Point3f objectPoints=, ARG vector_vector_Point2f imagePoints=, ARG Size imageSize=, ARG double aspectRatio=1.0]>
FUNC <void cv..drawChessboardCorners [ARG Mat image=, ARG Size patternSize=, ARG vector_Point2f corners=, ARG bool patternWasFound=]>
FUNC <bool cv..findCirclesGrid [ARG Mat image=, ARG Size patternSize=, ARG Mat centers=, ARG int flags=CALIB_CB_SYMMETRIC_GRID, ARG Ptr_FeatureDetector blobDetector=SimpleBlobDetector::create()]>
FUNC <double cv..calibrateCamera [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints=, ARG Size imageSize=, ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG vector_Mat rvecs=, ARG vector_Mat tvecs=, ARG int flags=0, ARG TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON)]>
FUNC <void cv..calibrationMatrixValues [ARG Mat cameraMatrix=, ARG Size imageSize=, ARG double apertureWidth=, ARG double apertureHeight=, ARG double fovx=, ARG double fovy=, ARG double focalLength=, ARG Point2d principalPoint=, ARG double aspectRatio=]>
FUNC <double cv..stereoCalibrate [ARG vector_Mat objectPoints=, ARG vector_Mat imagePoints1=, ARG vector_Mat imagePoints2=, ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat E=, ARG Mat F=, ARG int flags=CALIB_FIX_INTRINSIC, ARG TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6)]>
FUNC <void cv..stereoRectify [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Size imageSize=, ARG Mat R=, ARG Mat T=, ARG Mat R1=, ARG Mat R2=, ARG Mat P1=, ARG Mat P2=, ARG Mat Q=, ARG int flags=CALIB_ZERO_DISPARITY, ARG double alpha=-1, ARG Size newImageSize=Size(), ARG Rect * validPixROI1=0, ARG Rect * validPixROI2=0]>
FUNC <bool cv..stereoRectifyUncalibrated [ARG Mat points1=, ARG Mat points2=, ARG Mat F=, ARG Size imgSize=, ARG Mat H1=, ARG Mat H2=, ARG double threshold=5]>
FUNC <float cv..rectify3Collinear [ARG Mat cameraMatrix1=, ARG Mat distCoeffs1=, ARG Mat cameraMatrix2=, ARG Mat distCoeffs2=, ARG Mat cameraMatrix3=, ARG Mat distCoeffs3=, ARG vector_Mat imgpt1=, ARG vector_Mat imgpt3=, ARG Size imageSize=, ARG Mat R12=, ARG Mat T12=, ARG Mat R13=, ARG Mat T13=, ARG Mat R1=, ARG Mat R2=, ARG Mat R3=, ARG Mat P1=, ARG Mat P2=, ARG Mat P3=, ARG Mat Q=, ARG double alpha=, ARG Size newImgSize=, ARG Rect * roi1=, ARG Rect * roi2=, ARG int flags=]>
FUNC <Mat cv..getOptimalNewCameraMatrix [ARG Mat cameraMatrix=, ARG Mat distCoeffs=, ARG Size imageSize=, ARG double alpha=, ARG Size newImgSize=Size(), ARG Rect * validPixROI=0, ARG bool centerPrincipalPoint=false]>
FUNC <void cv..convertPointsToHomogeneous [ARG Mat src=, ARG Mat dst=]>
FUNC <void cv..convertPointsFromHomogeneous [ARG Mat src=, ARG Mat dst=]>
FUNC <Mat cv..findFundamentalMat [ARG vector_Point2f points1=, ARG vector_Point2f points2=, ARG int method=FM_RANSAC, ARG double param1=3., ARG double param2=0.99, ARG Mat mask=Mat()]>
